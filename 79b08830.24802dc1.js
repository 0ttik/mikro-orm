(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{206:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return p}));var o=t(1),a=t(9),r=(t(0),t(288)),i={title:"Entity References",sidebar_label:"Entity References and Reference<T> Wrapper"},c=[{value:"Assigning to Reference Properties",id:"assigning-to-reference-properties",children:[]},{value:"What is IdentifiedReference?",id:"what-is-identifiedreference",children:[]}],l={rightToc:c},s="wrapper";function p(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(s,Object(o.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Every single entity relation is mapped to an entity reference. Reference is an entity that has\nonly its identifier. This reference is stored in identity map so you will get the same object\nreference when fetching the same document from database."),Object(r.b)("p",null,"You can call ",Object(r.b)("inlineCode",{parentName:"p"},"await entity.init()")," to initialize the entity. This will trigger database call\nand populate itself, keeping the same reference in identity map. "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"const author = orm.em.getReference('...id...');\nconsole.log(author.id); // accessing the id will not trigger any db call\nconsole.log(author.isInitialized()); // false\nconsole.log(author.name); // undefined\n\nawait author.init(); // this will trigger db call\nconsole.log(author.isInitialized()); // true\nconsole.log(author.name); // defined\n")),Object(r.b)("h1",{id:"better-type-safety-with-referencet-wrapper"},"Better Type-safety with ",Object(r.b)("inlineCode",{parentName:"h1"},"Reference<T>")," Wrapper"),Object(r.b)("p",null,"When you define ",Object(r.b)("inlineCode",{parentName:"p"},"@ManyToOne")," and ",Object(r.b)("inlineCode",{parentName:"p"},"@OneToOne")," properties on your entity, TypeScript compiler\nwill think that desired entities are always loaded:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"@Entity()\nexport class Book implements IdEntity<Book> {\n\n  @PrimaryKey()\n  id!: number;\n\n  @ManyToOne()\n  author!: Author;\n\n  constructor(author: Author) {\n    this.author = author;\n  }\n\n}\n\nconst book = await orm.em.findOne(Book, 1);\nconsole.log(book.author instanceof Author); // true\nconsole.log(book.author.isInitialized()); // false\nconsole.log(book.author.name); // undefined as `Author` is not loaded yet\n")),Object(r.b)("p",null,"You can overcome this issue by using the ",Object(r.b)("inlineCode",{parentName:"p"},"Reference<T>")," wrapper. It simply wraps the entity,\ndefining ",Object(r.b)("inlineCode",{parentName:"p"},"load(): Promise<T>")," method that will first lazy load the association if not already\navailable. You can also use ",Object(r.b)("inlineCode",{parentName:"p"},"unwrap(): T")," method to access the underlying entity without loading\nit."),Object(r.b)("p",null,"You can also use ",Object(r.b)("inlineCode",{parentName:"p"},"get<K extends keyof T>(prop: K): Promise<T[K]>")," helper, that will call ",Object(r.b)("inlineCode",{parentName:"p"},"load()"),"\nfor you, making sure the entity is initialized first, then returning the value of given property\ndirectly. "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Entity, IdentifiedReference, ManyToOne, PrimaryKey, Reference } from 'mikro-orm';\n\n@Entity()\nexport class Book implements IdEntity<Book> {\n\n  @PrimaryKey()\n  id!: number;\n\n  @ManyToOne()\n  author!: IdentifiedReference<Author>;\n\n  constructor(author: Author) {\n    this.author = Reference.create(author);\n  }\n\n}\n\nconst book = await orm.em.findOne(Book, 1);\nconsole.log(book.author instanceof Reference); // true\nconsole.log(book.author.isInitialized()); // false\nconsole.log(book.author.name); // type error, there is no `name` property\nconsole.log(book.author.unwrap().name); // undefined as author is not loaded\nconsole.log((await book.author.get('name'))); // ok, loading the author first\nconsole.log((await book.author.load()).name); // ok, author already loaded\nconsole.log(book.author.unwrap().name); // ok, author already loaded\n")),Object(r.b)("h2",{id:"assigning-to-reference-properties"},"Assigning to Reference Properties"),Object(r.b)("p",null,"When you define the property as ",Object(r.b)("inlineCode",{parentName:"p"},"Reference")," wrapper, you will need to assign the ",Object(r.b)("inlineCode",{parentName:"p"},"Reference"),"\nto it instead of the entity. You can create it via ",Object(r.b)("inlineCode",{parentName:"p"},"Reference.create()")," factory, or use ",Object(r.b)("inlineCode",{parentName:"p"},"wrapped"),"\nparameter of ",Object(r.b)("inlineCode",{parentName:"p"},"em.getReference()"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"const book = await orm.em.findOne(Book, 1);\nconst repo = orm.em.getRepository(Author);\n\nbook.author = repo.getReference(2, true);\n\n// same as:\nbook.author = Reference.create(repo.getReference(2));\nawait orm.em.flush();\n")),Object(r.b)("h2",{id:"what-is-identifiedreference"},"What is IdentifiedReference?"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"IdentifiedReference")," is an intersection type that adds primary key property to the ",Object(r.b)("inlineCode",{parentName:"p"},"Reference"),"\ninterface. It allows to get the primary key from ",Object(r.b)("inlineCode",{parentName:"p"},"Reference")," instance directly."),Object(r.b)("p",null,"By default it defines the PK property as ",Object(r.b)("inlineCode",{parentName:"p"},"id"),", you can override this via second generic type\nargument."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"const book = await orm.em.findOne(Book, 1);\nconsole.log(book.author.id); // ok, returns the PK\n")),Object(r.b)("p",null,"You can also have non-standard primary key like ",Object(r.b)("inlineCode",{parentName:"p"},"uuid"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"@Entity()\nexport class Book implements IdEntity<Book> {\n\n  @PrimaryKey()\n  id!: number;\n\n  @ManyToOne()\n  author!: IdentifiedReference<Author, 'uuid'>;\n\n}\n\nconst book = await orm.em.findOne(Book, 1);\nconsole.log(book.author.uuid); // ok, returns the PK\n")),Object(r.b)("p",null,"For MongoDB, defined the PK generic type argument as ",Object(r.b)("inlineCode",{parentName:"p"},"'id' | '_id'")," to access both ",Object(r.b)("inlineCode",{parentName:"p"},"string"),"\nand ",Object(r.b)("inlineCode",{parentName:"p"},"ObjectId")," PK values:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"@Entity()\nexport class Book implements MongoEntity<Book> {\n\n  @PrimaryKey()\n  _id!: ObjectId;\n\n  @SerializedPrimaryKey()\n  id!: string;\n\n  @ManyToOne()\n  author!: IdentifiedReference<Author, 'id' | '_id'>;\n\n}\n\nconst book = await orm.em.findOne(Book, 1);\nconsole.log(book.author.id); // ok, returns string PK\nconsole.log(book.author._id); // ok, returns ObjectId PK\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"As opposed to ",Object(r.b)("inlineCode",{parentName:"p"},"Entity.init()")," which always refreshes the entity, ",Object(r.b)("inlineCode",{parentName:"p"},"Reference.load()"),"\nmethod will query the database only if the entity is not already loaded in Identity Map. ")))}p.isMDXComponent=!0},288:function(e,n,t){"use strict";t.d(n,"a",(function(){return c})),t.d(n,"b",(function(){return d}));var o=t(0),a=t.n(o),r=a.a.createContext({}),i=function(e){var n=a.a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},c=function(e){var n=i(e.components);return a.a.createElement(r.Provider,{value:n},e.children)};var l="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},p=Object(o.forwardRef)((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,l=function(e,n){var t={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&-1===n.indexOf(o)&&(t[o]=e[o]);return t}(e,["components","mdxType","originalType","parentName"]),p=i(t),d=o,u=p[c+"."+d]||p[d]||s[d]||r;return t?a.a.createElement(u,Object.assign({},{ref:n},l,{components:t})):a.a.createElement(u,Object.assign({},{ref:n},l))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=p;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[l]="string"==typeof e?e:o,i[1]=c;for(var d=2;d<r;d++)i[d]=t[d];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);